use anyhow::Result;
use jstz_crypto::{public_key::PublicKey, smart_function_hash::SmartFunctionHash};
use jstz_kernel::{INJECTOR, TICKETER};
use std::{
    env, fs,
    path::{Path, PathBuf},
};
use tezos_crypto_rs::hash::ContractKt1Hash;
use tezos_smart_rollup::storage::path::OwnedPath;
use tezos_smart_rollup_installer::{
    installer, preimages, KERNEL_BOOT_PATH, PREPARE_KERNEL_PATH,
};

include!("build_config.rs");

/// The jstz kernel path used to generate the rollup installer / preimages.
/// generated by running `make build build-jstzd-kernel`
const JSTZ_KERNEL_PATH: &str = "./resources/jstz_rollup/jstz_kernel.wasm";
const JSTZ_PARAMETERS_TY_PATH: &str = "./resources/jstz_rollup/parameters_ty.json";
/// Generated file that contains path getter functions
const JSTZ_ROLLUP_PATH: &str = "jstz_rollup_path.rs";

/// Build script that generates and saves the following files in OUT_DIR:
///
/// Files copied:
/// - parameters_ty.json: JSON file containing parameter types
///
/// Files generated:
/// - kernel_installer.hex: Hex-encoded kernel installer binary
/// - preimages/: Directory containing kernel preimages
/// - jstz_rollup_path.rs: Generated Rust code with path getters
///
/// The generated jstz_rollup_path.rs provides the following functions:
/// - kernel_installer_path(): Path to the kernel installer hex file
/// - parameters_ty_path(): Path to the parameters type JSON file
/// - preimages_path(): Path to the preimages directory
fn main() {
    println!("cargo:rerun-if-changed={}", JSTZ_KERNEL_PATH);
    println!("cargo:rerun-if-changed={}", JSTZ_PARAMETERS_TY_PATH);

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // 1. Copy parameters_ty.json to OUT_DIR
    fs::copy(JSTZ_PARAMETERS_TY_PATH, out_dir.join("parameters_ty.json"))
        .expect("Failed to copy parameters_ty.json to OUT_DIR");

    // 2. Create preimages directory and the kernel installer in OUT_DIR
    let preimages_dir = out_dir.join("preimages");
    fs::create_dir_all(&preimages_dir).expect("Failed to create preimages directory");
    let kernel_installer =
        make_kernel_installer(PathBuf::from(JSTZ_KERNEL_PATH).as_path(), &preimages_dir)
            .expect("Failed to make kernel installer");

    // 3. Save hex-encoded kernel installer to OUT_DIR
    fs::write(out_dir.join("kernel_installer.hex"), kernel_installer)
        .expect("Failed to write kernel_installer.hex");

    // 4. Generate path getter code in OUT_DIR
    generate_code(&out_dir);

    println!(
        "cargo:warning=Build script output directory: {}",
        out_dir.display()
    );
    if let Ok(p) = env::var("KERNEL_DEST_DIR") {
        println!(
            "cargo:warning=Copying content in output directory to: {}",
            p
        );
        fs::create_dir_all(&p).unwrap_or_else(|e| {
            panic!("Failed to create destination directory '{}': {:?}", &p, e)
        });
        copy_dir_all(out_dir, &p).unwrap_or_else(|e| {
            panic!("Failed to copy kernel files to '{}': {:?}", &p, e)
        });
    }
}

fn copy_dir_all(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> std::io::Result<()> {
    fs::create_dir_all(&dst)?;
    for entry_ in fs::read_dir(src)? {
        let entry = entry_?;
        let src_path = entry.path();
        let dst_path = dst.as_ref().join(entry.file_name());
        if src_path.is_dir() {
            copy_dir_all(src_path, dst_path)?;
        } else {
            fs::copy(src_path, dst_path)?;
        }
    }
    Ok(())
}

/// Builds the kernel installer and generates preimages
///
/// # Arguments
/// * `kernel_file` - Path to the kernel wasm file
/// * `preimages_dir` - Directory where preimages will be saved
///
/// # Returns
/// Hex-encoded kernel installer string
fn make_kernel_installer(kernel_file: &Path, preimages_dir: &Path) -> Result<String> {
    if !kernel_file.exists() {
        return Err(anyhow::anyhow!(
            "kernel file not found: {}",
            kernel_file.display()
        ));
    }
    let root_hash = preimages::content_to_preimages(kernel_file, preimages_dir)?;
    let installer_program = OwnedConfigProgram(vec![
        // 1. Prepare kernel installer
        OwnedConfigInstruction::reveal_instr(
            root_hash,
            OwnedPath::from(PREPARE_KERNEL_PATH),
        ),
        OwnedConfigInstruction::move_instr(
            OwnedPath::from(PREPARE_KERNEL_PATH),
            OwnedPath::from(KERNEL_BOOT_PATH),
        ),
        // 2. Set `jstz` ticketer as the bridge contract address
        OwnedConfigInstruction::set_instr(
            OwnedBytes(bincode::encode_to_vec(
                SmartFunctionHash(
                    ContractKt1Hash::from_base58_check(EXCHANGER_ADDRESS)?.into(),
                ),
                bincode::config::legacy(),
            )?),
            OwnedPath::from(TICKETER),
        ),
        // 3. Set `jstz` injector as the `jstz_node` account
        OwnedConfigInstruction::set_instr(
            OwnedBytes(bincode::encode_to_vec(
                PublicKey::from_base58(INJECTOR_PK)?,
                bincode::config::legacy(),
            )?),
            OwnedPath::from(INJECTOR),
        ),
    ]);
    let installer = installer::with_config_program(installer_program);
    Ok(hex::encode(&installer))
}

/// Generates Rust code for path getters to access files in OUT_DIR
///
/// Generates the following functions:
/// - kernel_installer_path(): Path to the kernel installer hex file
/// - parameters_ty_path(): Path to the parameters type JSON file
/// - preimages_path(): Path to the preimages directory
fn generate_code(out_dir: &Path) {
    let mut code = String::new();
    code.push_str(&generate_path_getter_code(
        out_dir,
        "kernel_installer",
        "kernel_installer.hex",
    ));
    code.push_str(&generate_path_getter_code(
        out_dir,
        "parameters_ty",
        "parameters_ty.json",
    ));
    code.push_str(&generate_path_getter_code(
        out_dir,
        "preimages",
        "preimages",
    ));

    fs::write(out_dir.join(JSTZ_ROLLUP_PATH), code).expect("Failed to write paths.rs");
}

/// Generates a path getter function
///
/// # Arguments
/// * `out_dir` - The output directory
/// * `fn_name` - The name of the function to generate (e.g., "kernel_installer" generates kernel_installer_path())
/// * `path_suffix` - The path component to append to out_dir
///
/// # Example
/// ```
/// // Generates:
/// // const KERNEL_INSTALLER_PATH: &str = "/path/to/out_dir/kernel_installer.hex";
/// // pub fn kernel_installer_path() -> PathBuf { PathBuf::from(KERNEL_INSTALLER_PATH) }
/// generate_path_getter_code(out_dir, "kernel_installer", "kernel_installer.hex");
/// ```
fn generate_path_getter_code(out_dir: &Path, fn_name: &str, path_suffix: &str) -> String {
    let name_upper = fn_name.to_uppercase();
    format!(
        r#"
        const {}_PATH: &str = "{}";
        pub fn {}_path() -> std::path::PathBuf {{
            let path = std::path::PathBuf::from({}_PATH);
            if path.exists() {{
                path
            }} else {{
                std::path::PathBuf::from("/usr/share/jstzd/{}")
            }}
        }}
        "#,
        &name_upper,
        out_dir.join(path_suffix).to_str().expect("Invalid path"),
        fn_name,
        &name_upper,
        path_suffix
    )
}
