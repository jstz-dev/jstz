use anyhow::Result;
use jstz_crypto::{
    public_key::PublicKey, secret_key::SecretKey, smart_function_hash::SmartFunctionHash,
};
use jstz_kernel::{INJECTOR, TICKETER};
use std::{
    collections::HashMap,
    env, fs,
    path::{Path, PathBuf},
};
use tezos_crypto_rs::hash::ContractKt1Hash;
use tezos_smart_rollup::storage::path::OwnedPath;
use tezos_smart_rollup_installer::{
    installer, preimages, KERNEL_BOOT_PATH, PREPARE_KERNEL_PATH,
};
use tezos_smart_rollup_installer_config::binary::owned::{
    OwnedBytes, OwnedConfigInstruction, OwnedConfigProgram,
};

include!("build_config.rs");

/// The jstz kernel path used to generate the rollup installer / preimages.
/// generated by running `make build build-jstzd-kernel`
const JSTZ_KERNEL_PATH: &str = "./resources/jstz_rollup/jstz_kernel.wasm";
const JSTZ_PARAMETERS_TY_PATH: &str = "./resources/jstz_rollup/parameters_ty.json";
/// Generated file that contains path getter functions
const JSTZ_ROLLUP_PATH: &str = "jstz_rollup_path.rs";
const BOOTSTRAP_ACCOUNT_PATH: &str = "./resources/bootstrap_account/accounts.json";
// These aliases are also used by jstzd during config validation.
const ACTIVATOR_BOOTSTRAP_ACCOUNT_ALIAS: &str = "activator";
const INJECTOR_BOOTSTRAP_ACCOUNT_ALIAS: &str = "injector";
const ROLLUP_OPERATOR_BOOTSTRAP_ACCOUNT_ALIAS: &str = "rollup_operator";

/// Build script that validates built-in bootstrap accounts and generates and saves
/// the following files in OUT_DIR:
///
/// Files copied:
/// - parameters_ty.json: JSON file containing parameter types
///
/// Files generated:
/// - kernel_installer.hex: Hex-encoded kernel installer binary
/// - preimages/: Directory containing kernel preimages
/// - jstz_rollup_path.rs: Generated Rust code with path getters
///
/// The generated jstz_rollup_path.rs provides the following functions:
/// - kernel_installer_path(): Path to the kernel installer hex file
/// - parameters_ty_path(): Path to the parameters type JSON file
/// - preimages_path(): Path to the preimages directory
fn main() {
    println!("cargo:rerun-if-changed={JSTZ_KERNEL_PATH}");
    println!("cargo:rerun-if-changed={JSTZ_PARAMETERS_TY_PATH}");
    println!("cargo:rerun-if-changed={BOOTSTRAP_ACCOUNT_PATH}");

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // 1. Copy parameters_ty.json to OUT_DIR
    fs::copy(JSTZ_PARAMETERS_TY_PATH, out_dir.join("parameters_ty.json"))
        .expect("Failed to copy parameters_ty.json to OUT_DIR");

    // 2. Validate built-in bootstrap accounts stored in the resource file
    let bootstrap_accounts = validate_builtin_bootstrap_accounts();

    // 3. Create preimages directory and the kernel installer in OUT_DIR
    let preimages_dir = out_dir.join("preimages");
    fs::create_dir_all(&preimages_dir).expect("Failed to create preimages directory");
    let injector_pk = bootstrap_accounts
        .get(INJECTOR_BOOTSTRAP_ACCOUNT_ALIAS)
        .expect("injector bootstrap account should exist")
        .clone();
    let kernel_installer = make_kernel_installer(
        PathBuf::from(JSTZ_KERNEL_PATH).as_path(),
        &preimages_dir,
        injector_pk,
    )
    .expect("Failed to make kernel installer");

    // 4. Save hex-encoded kernel installer to OUT_DIR
    fs::write(out_dir.join("kernel_installer.hex"), kernel_installer)
        .expect("Failed to write kernel_installer.hex");

    // 5. Generate path getter code in OUT_DIR
    generate_code(&out_dir);

    println!(
        "cargo:warning=Build script output directory: {}",
        out_dir.display()
    );
    if let Ok(p) = env::var("KERNEL_DEST_DIR") {
        println!("cargo:warning=Copying content in output directory to: {p}");
        fs::create_dir_all(&p).unwrap_or_else(|e| {
            panic!("Failed to create destination directory '{}': {:?}", &p, e)
        });
        copy_dir_all(out_dir, &p).unwrap_or_else(|e| {
            panic!("Failed to copy kernel files to '{}': {:?}", &p, e)
        });
    }
}

fn copy_dir_all(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> std::io::Result<()> {
    fs::create_dir_all(&dst)?;
    for entry_ in fs::read_dir(src)? {
        let entry = entry_?;
        let src_path = entry.path();
        let dst_path = dst.as_ref().join(entry.file_name());
        if src_path.is_dir() {
            copy_dir_all(src_path, dst_path)?;
        } else {
            fs::copy(src_path, dst_path)?;
        }
    }
    Ok(())
}

/// Builds the kernel installer and generates preimages
///
/// # Arguments
/// * `kernel_file` - Path to the kernel wasm file
/// * `preimages_dir` - Directory where preimages will be saved
///
/// # Returns
/// Hex-encoded kernel installer string
fn make_kernel_installer(
    kernel_file: &Path,
    preimages_dir: &Path,
    injector_pk: PublicKey,
) -> Result<String> {
    if !kernel_file.exists() {
        return Err(anyhow::anyhow!(
            "kernel file not found: {}",
            kernel_file.display()
        ));
    }
    let content = fs::read(kernel_file)?;
    let root_hash = preimages::content_to_preimages(content, preimages_dir)?;
    let installer_program = OwnedConfigProgram(vec![
        // 1. Prepare kernel installer
        OwnedConfigInstruction::reveal_instr(
            root_hash,
            OwnedPath::from(PREPARE_KERNEL_PATH),
        ),
        OwnedConfigInstruction::move_instr(
            OwnedPath::from(PREPARE_KERNEL_PATH),
            OwnedPath::from(KERNEL_BOOT_PATH),
        ),
        // 2. Set `jstz` ticketer as the bridge contract address
        OwnedConfigInstruction::set_instr(
            OwnedBytes(bincode::encode_to_vec(
                SmartFunctionHash(
                    ContractKt1Hash::from_base58_check(EXCHANGER_ADDRESS)?.into(),
                ),
                bincode::config::legacy(),
            )?),
            OwnedPath::from(TICKETER),
        ),
        // 3. Set `jstz` injector as the `jstz_node` account
        OwnedConfigInstruction::set_instr(
            OwnedBytes(bincode::encode_to_vec(
                injector_pk,
                bincode::config::legacy(),
            )?),
            OwnedPath::from(INJECTOR),
        ),
    ]);
    let installer = installer::with_config_program(installer_program);
    Ok(hex::encode(&installer))
}

/// Generates Rust code for path getters to access files in OUT_DIR
///
/// Generates the following functions:
/// - kernel_installer_path(): Path to the kernel installer hex file
/// - parameters_ty_path(): Path to the parameters type JSON file
/// - preimages_path(): Path to the preimages directory
fn generate_code(out_dir: &Path) {
    let mut code = String::new();
    code.push_str(&generate_path_getter_code(
        out_dir,
        "kernel_installer",
        "kernel_installer.hex",
    ));
    code.push_str(&generate_path_getter_code(
        out_dir,
        "parameters_ty",
        "parameters_ty.json",
    ));
    code.push_str(&generate_path_getter_code(
        out_dir,
        "preimages",
        "preimages",
    ));

    fs::write(out_dir.join(JSTZ_ROLLUP_PATH), code).expect("Failed to write paths.rs");
}

/// Generates a path getter function
///
/// # Arguments
/// * `out_dir` - The output directory
/// * `fn_name` - The name of the function to generate (e.g., "kernel_installer" generates kernel_installer_path())
/// * `path_suffix` - The path component to append to out_dir
///
/// # Example
/// ```
/// // Generates:
/// // const KERNEL_INSTALLER_PATH: &str = "/path/to/out_dir/kernel_installer.hex";
/// // pub fn kernel_installer_path() -> PathBuf { PathBuf::from(KERNEL_INSTALLER_PATH) }
/// generate_path_getter_code(out_dir, "kernel_installer", "kernel_installer.hex");
/// ```
fn generate_path_getter_code(out_dir: &Path, fn_name: &str, path_suffix: &str) -> String {
    let name_upper = fn_name.to_uppercase();
    format!(
        r#"
        const {}_PATH: &str = "{}";
        pub fn {}_path() -> std::path::PathBuf {{
            let path = std::path::PathBuf::from({}_PATH);
            if path.exists() {{
                path
            }} else {{
                std::path::PathBuf::from("/usr/share/jstzd/{}")
            }}
        }}
        "#,
        &name_upper,
        out_dir.join(path_suffix).to_str().expect("Invalid path"),
        fn_name,
        &name_upper,
        path_suffix
    )
}

fn validate_builtin_bootstrap_accounts() -> HashMap<String, PublicKey> {
    let bytes =
        fs::read(BOOTSTRAP_ACCOUNT_PATH).expect("failed to read bootstrap account file");
    let raw_accounts: Vec<(String, String, String, u64)> = serde_json::from_slice(&bytes)
        .unwrap_or_else(|e| panic!("failed to parse built-in bootstrap accounts: {e:?}"));
    let mut mapping = HashMap::new();
    for (name, pk, raw_sk, _) in raw_accounts {
        let public_key = PublicKey::from_base58(&pk).unwrap_or_else(|e| {
            panic!("failed to parse public key of bootstrap account '{name}': {e:?}")
        });
        let sk = if raw_sk.starts_with("unencrypted") {
            raw_sk.split(':').nth(1).unwrap()
        } else {
            &raw_sk
        };
        SecretKey::from_base58(sk).unwrap_or_else(|e| {
            panic!("failed to parse secret key of bootstrap account '{name}': {e:?}")
        });
        if mapping.insert(name.clone(), public_key).is_some() {
            panic!("bootstrap account name '{name}' already exists");
        }
    }
    for required_alias in [
        INJECTOR_BOOTSTRAP_ACCOUNT_ALIAS,
        ACTIVATOR_BOOTSTRAP_ACCOUNT_ALIAS,
        ROLLUP_OPERATOR_BOOTSTRAP_ACCOUNT_ALIAS,
    ] {
        if !mapping.contains_key(ACTIVATOR_BOOTSTRAP_ACCOUNT_ALIAS) {
            panic!("there must be one built-in bootstrap account with alias '{required_alias}'");
        }
    }
    mapping
}
