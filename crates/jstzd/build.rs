use anyhow::Result;
use jstz_kernel::TICKETER;
use std::{
    env, fs,
    path::{Path, PathBuf},
};
use tezos_crypto_rs::hash::ContractKt1Hash;
use tezos_smart_rollup_host::path::OwnedPath;
use tezos_smart_rollup_installer::{
    installer, preimages, KERNEL_BOOT_PATH, PREPARE_KERNEL_PATH,
};
use tezos_smart_rollup_installer_config::binary::owned::{
    OwnedBytes, OwnedConfigInstruction, OwnedConfigProgram,
};

include!("build_config.rs");

/// The jstz kernel path used to generate the rollup installer / preimages.
/// generated by running `make build build-jstzd-kernel`
const JSTZ_KERNEL_PATH: &str = "./resources/jstz_rollup/jstz_kernel.wasm";
const JSTZ_PARAMETERS_TY_PATH: &str = "./resources/jstz_rollup/parameters_ty.json";
/// Generated file that contains path getter functions
const JSTZ_ROLLUP_PATH: &str = "jstz_rollup_path.rs";

/// Build script that generates and saves the following files in OUT_DIR:
///
/// Files copied:
/// - parameters_ty.json: JSON file containing parameter types
///
/// Files generated:
/// - kernel_installer.hex: Hex-encoded kernel installer binary
/// - preimages/: Directory containing kernel preimages
/// - jstz_rollup_path.rs: Generated Rust code with path getters
///
/// The generated jstz_rollup_path.rs provides the following functions:
/// - kernel_installer_path(): Path to the kernel installer hex file
/// - parameters_ty_path(): Path to the parameters type JSON file
/// - preimages_path(): Path to the preimages directory
fn main() {
    println!("cargo:rerun-if-changed={}", JSTZ_KERNEL_PATH);
    println!("cargo:rerun-if-changed={}", JSTZ_PARAMETERS_TY_PATH);

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // 1. Copy parameters_ty.json to OUT_DIR
    fs::copy(JSTZ_PARAMETERS_TY_PATH, out_dir.join("parameters_ty.json"))
        .expect("Failed to copy parameters_ty.json to OUT_DIR");

    // 2. Create preimages directory and the kernel installer in OUT_DIR
    let preimages_dir = out_dir.join("preimages");
    fs::create_dir_all(&preimages_dir).expect("Failed to create preimages directory");
    let kernel_installer =
        make_kernel_installer(PathBuf::from(JSTZ_KERNEL_PATH).as_path(), &preimages_dir)
            .expect("Failed to make kernel installer");

    // 3. Save hex-encoded kernel installer to OUT_DIR
    fs::write(out_dir.join("kernel_installer.hex"), kernel_installer)
        .expect("Failed to write kernel_installer.hex");

    // 4. Generate path getter code in OUT_DIR
    generate_code(&out_dir);

    println!(
        "cargo:warning=Build script output directory: {}",
        out_dir.display()
    );
}

/// Builds the kernel installer and generates preimages
///
/// # Arguments
/// * `kernel_file` - Path to the kernel wasm file
/// * `preimages_dir` - Directory where preimages will be saved
///
/// # Returns
/// Hex-encoded kernel installer string
fn make_kernel_installer(kernel_file: &Path, preimages_dir: &Path) -> Result<String> {
    if !kernel_file.exists() {
        return Err(anyhow::anyhow!(
            "kernel file not found: {}",
            kernel_file.display()
        ));
    }
    let root_hash = preimages::content_to_preimages(kernel_file, preimages_dir)?;
    let installer_program = OwnedConfigProgram(vec![
        // 1. Prepare kernel installer
        OwnedConfigInstruction::reveal_instr(
            root_hash,
            OwnedPath::from(PREPARE_KERNEL_PATH),
        ),
        OwnedConfigInstruction::move_instr(
            OwnedPath::from(PREPARE_KERNEL_PATH),
            OwnedPath::from(KERNEL_BOOT_PATH),
        ),
        // 2. Set `jstz` ticketer as the bridge contract address
        OwnedConfigInstruction::set_instr(
            OwnedBytes(bincode::serialize(&ContractKt1Hash::from_base58_check(
                EXCHANGER_ADDRESS,
            )?)?),
            OwnedPath::from(TICKETER),
        ),
    ]);
    let installer = installer::with_config_program(installer_program);
    Ok(hex::encode(&installer))
}

/// Generates Rust code for path getters to access files in OUT_DIR
///
/// Generates the following functions:
/// - kernel_installer_path(): Path to the kernel installer hex file
/// - parameters_ty_path(): Path to the parameters type JSON file
/// - preimages_path(): Path to the preimages directory
fn generate_code(out_dir: &Path) {
    let mut code = String::new();

    code.push_str(&generate_path_getter_code(
        out_dir,
        "kernel_installer",
        "kernel_installer.hex",
    ));
    code.push_str(&generate_path_getter_code(
        out_dir,
        "parameters_ty",
        "parameters_ty.json",
    ));
    code.push_str(&generate_path_getter_code(
        out_dir,
        "preimages",
        "preimages",
    ));

    fs::write(out_dir.join(JSTZ_ROLLUP_PATH), code).expect("Failed to write paths.rs");
}

/// Generates a path getter function
///
/// # Arguments
/// * `out_dir` - The output directory
/// * `fn_name` - The name of the function to generate (e.g., "kernel_installer" generates kernel_installer_path())
/// * `path_suffix` - The path component to append to out_dir
///
/// # Example
/// ```
/// // Generates:
/// // const KERNEL_INSTALLER_PATH: &str = "/path/to/out_dir/kernel_installer.hex";
/// // pub fn kernel_installer_path() -> PathBuf { PathBuf::from(KERNEL_INSTALLER_PATH) }
/// generate_path_getter_code(out_dir, "kernel_installer", "kernel_installer.hex");
/// ```
fn generate_path_getter_code(out_dir: &Path, fn_name: &str, path_suffix: &str) -> String {
    let name_upper = fn_name.to_uppercase();

    let result = format!(
        r#"
        const {name_upper:}_PATH: &str = "{}";
            pub fn {fn_name:}_path() -> std::path::PathBuf {{
                std::path::PathBuf::from({name_upper:}_PATH)
            }}
        "#,
        out_dir.join(path_suffix).to_str().expect("Invalid path"),
    );
    result
}
